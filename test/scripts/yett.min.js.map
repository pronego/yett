{"version":3,"file":"yett.min.js","sources":["../../src/checks.js","../../src/variables.js","../../src/observer.js","../../src/monkey.js","../../src/unblock.js"],"sourcesContent":["import { patterns, TYPE_ATTRIBUTE } from './variables'\n\nexport const isOnBlacklist = (src, type) => (\n    src && (!type || type !== TYPE_ATTRIBUTE) &&\n    isBlacklistedSource(src, false)\n)\n\nexport const isOnBlacklistKey = (src, type) => (\n    src && (!type || type !== TYPE_ATTRIBUTE) &&\n    isBlacklistedSource(src, true)\n)\n\nexport const isBlacklistedSource = function(src, return_key) {\n  const srcStart = (src === undefined || src == null ? \"\" : src.toString().split(\"?\")[0]);\n  let i = null;\n  if (srcStart &&\n  (\n    // No blacklist exists or one matches\n    (!patterns.blacklist || patterns.blacklist.some((pattern, index) => {\n        if (pattern.test(srcStart)) {\n            i = index; // Remember index in blacklist\n            return true;\n        } else {\n            return false;\n        }\n    }))\n\n    // No whitelist or all do not match\n    && (!patterns.whitelist || patterns.whitelist.every(pattern => !pattern.test(srcStart)))\n  )) {\n      return (return_key ? i : true);\n  }\n  else\n      return false;\n}\n\nexport const willBeUnblocked = function(script) {\n    const src = script.getAttribute('src')\n    return (\n        patterns.blacklist && patterns.blacklist.every(entry => !entry.test(src)) ||\n        patterns.whitelist && patterns.whitelist.some(entry => entry.test(src))\n    )\n}\n","export const TYPE_ATTRIBUTE = 'javascript/blocked'\nexport const HIDDEN_SRC_ATTRIBUTE = 'yett-src'\n\nexport const patterns = {\n    blacklist: window.YETT_BLACKLIST,\n    whitelist: window.YETT_WHITELIST,\n    blacklistlabels: window.YETT_BLACKLIST_LABELS || [] // labels for the blacklist elements, same order as in blacklist\n}\n\nexport const features = {\n    iframe: window.YETT_IFRAME,\n    iframe_blocked_text: window.YETT_IFRAME_BLOCKED_TEXT || 'The following content was blocked due to your settings:',\n    iframe_blocked_btn_unblock: window.YETT_IFRAME_BLOCKED_BTN || 'Unblock',\n}\n\n// Backup list containing the original blacklisted elements\nexport const backupElements = {\n    blacklisted: []\n}\n","import {backupElements, TYPE_ATTRIBUTE, features, patterns} from './variables'\nimport { isOnBlacklistKey } from './checks'\n\n// Setup a mutation observer to track DOM insertion\nexport const observer = new MutationObserver(mutations => {\n    for (let i = 0; i < mutations.length; i++) {\n        const { addedNodes } = mutations[i];\n        for(let i = 0; i < addedNodes.length; i++) {\n            const node = addedNodes[i]\n\n            // For each added script or iframe tag; nodeType=1 represents an Element node like <p> or <div>.\n            if(node.nodeType === 1 && (node.tagName === 'SCRIPT' || (features.iframe && node.tagName === 'IFRAME'))) {\n                const src = node.src || node.getAttribute('yett-src')\n                const type = node.type\n\n                // Special case for Contao dlh_googlemaps control script => Add button to placeholder\n                if (node.tagName === 'SCRIPT' && node.text && node.text.indexOf('dlh_googlemap') !== -1) {\n                    let contao_gmap = document.getElementsByClassName('dlh_googlemap')\n                    for (let i = 0; i < contao_gmap.length; i++) {\n                        // Add text + Button; in context WMM, use: class=\"toggleConsentManager\" instead of onclick attribute\n                        contao_gmap[i].classList.add(\"blocked\");\n                        contao_gmap[i].innerHTML = '<div style=\"text-align: center\"><p>'+features.iframe_blocked_text+' Google Maps'+'</p>'\n                            + '<p><button class=\"toggleConsentManager\">'+features.iframe_blocked_btn_unblock+'</button></p></div>'\n                    }\n                }\n\n                // If the src is inside the blacklist and is not inside the whitelist\n                let blacklistIndex = isOnBlacklistKey(src, type);\n                if(blacklistIndex !== null && blacklistIndex !== false) {\n                    // We backup the node\n                    backupElements.blacklisted.push([node, node.type])\n\n                   // Blocks inline script execution in Safari & Chrome\n                   node.type = TYPE_ATTRIBUTE\n\n                    // Firefox has this additional event which prevents scripts from beeing executed\n                    const beforeScriptExecuteListener = function (event) {\n                        // Prevent only marked scripts from executing\n                        if(node.getAttribute('type') === TYPE_ATTRIBUTE)\n                            event.preventDefault()\n                        node.removeEventListener('beforescriptexecute', beforeScriptExecuteListener)\n                    }\n                    node.addEventListener('beforescriptexecute', beforeScriptExecuteListener)\n\n                    // In case of iframe feature, add placeholder block\n                    if (features.iframe && node.tagName === 'IFRAME') {\n                        let label = patterns.blacklistlabels[blacklistIndex] ? '<br/>' + patterns.blacklistlabels[blacklistIndex] : ''\n                        let iframePlaceholder = document.createElement('div')\n                        iframePlaceholder.setAttribute('data-src', src)\n                        // Copy styles from iframe\n                        iframePlaceholder.style.cssText = document.defaultView.getComputedStyle(node, '').cssText\n                        // Set background color + special styles\n                        iframePlaceholder.style.backgroundColor = '#dedede'\n                        iframePlaceholder.style.display = 'flex'\n                        iframePlaceholder.style.alignItems = 'center'\n                        iframePlaceholder.style.justifyContent = 'center'\n                        iframePlaceholder.style.width = node.getAttribute('width')+'px'\n                        iframePlaceholder.style.height = node.getAttribute('height')+'px'\n                        iframePlaceholder.style.maxWidth = '100%'\n                        iframePlaceholder.classList.add('iframe-blocked')\n                        // Add text + Button; if not in context WMM, use: onclick=\"yett.unblock(\\''+src+'\\')\"\n                        iframePlaceholder.innerHTML = '<div style=\"text-align: center\"><p>'+features.iframe_blocked_text+label+'</p>'\n                            + '<p><button class=\"toggleConsentManager\">'+features.iframe_blocked_btn_unblock+'</button></p></div>'\n                        node.parentElement && node.parentElement.insertBefore(iframePlaceholder, node)\n                    }\n\n                    // Remove the node from the DOM\n                    node.parentElement && node.parentElement.removeChild(node)\n                }\n            }\n        }\n    }\n})\n\n// Starts the monitoring\nobserver.observe(document.documentElement, {\n    childList: true,\n    subtree: true\n})\n","import { TYPE_ATTRIBUTE, HIDDEN_SRC_ATTRIBUTE } from './variables'\nimport { isOnBlacklist } from './checks'\n\nconst createElementBackup = document.createElement\n\nvar originalDescriptors = {\n    script: {\n      class: HTMLScriptElement,\n      src: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'src'),\n      type: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'type')\n    }\n}\n\n// Monkey patch the createElement method to prevent dynamic scripts from executing\ndocument.createElement = function(...args) {\n    // If this is not a patched tag, bypass\n    const tagName = args[0].toLowerCase()\n    const descriptors = originalDescriptors[tagName]\n    if(descriptors === undefined)\n        return createElementBackup.bind(document)(...args)\n\n    const mockElt = createElementBackup.bind(document)(...args)\n\n    // Define getters / setters to ensure that the script type is properly set\n    try {\n        Object.defineProperties(mockElt, {\n            'src': {\n                get() {\n                    return descriptors.src.get.call(this)\n                },\n                set(value) {\n                    if(isOnBlacklist(value, mockElt.type)) {\n                        if (descriptors.type) {\n                          descriptors.type.set.call(this, TYPE_ATTRIBUTE)\n                        } else {\n                          descriptors.class.prototype.setAttribute.call(this, HIDDEN_SRC_ATTRIBUTE, value)\n                          value = undefined\n                        }\n                    }\n\n                    if(value !== undefined)\n                      descriptors.src.set.call(this, value)\n                }\n            },\n            'type': {\n                set(value) {\n                    const typeValue = isOnBlacklist(mockElt.src, mockElt.type) ? TYPE_ATTRIBUTE : value\n                    descriptors.type.set.call(this, typeValue)\n                }\n            }\n        })\n\n        // Monkey patch the setAttribute function so that the setter is called instead\n        mockElt.setAttribute = function(name, value) {\n            if(name === 'type' || name === 'src') {\n                mockElt[name] = value\n            } else\n                descriptors.class.prototype.setAttribute.call(mockElt, name, value)\n        }\n    } catch (error) {\n        // eslint-disable-next-line\n        console.warn(\n            'Yett: unable to prevent script execution for ' + tagName + ' src ', mockElt.src, '.\\n',\n            'A likely cause would be because you are using a third-party browser extension that monkey patches the \"document.createElement\" function.'\n        )\n    }\n    return mockElt\n}\n","import {\n    patterns,\n    backupElements,\n    TYPE_ATTRIBUTE,\n    HIDDEN_SRC_ATTRIBUTE\n} from './variables'\n\nimport {\n    willBeUnblocked\n} from './checks'\n\nimport {\n    observer\n} from './observer'\n\nconst URL_REPLACER_REGEXP = new RegExp('[|\\\\{}()[\\\\]^$+*?.]', 'g')\n\n// Unblocks all (or a selection of) blacklisted scripts.\nexport const unblock = function(...scriptUrlsOrRegexes) {\n    if(scriptUrlsOrRegexes.length < 1) {\n        patterns.blacklist = []\n        patterns.whitelist = []\n    } else {\n        if(patterns.blacklist) {\n            patterns.blacklist = patterns.blacklist.filter(pattern => (\n                scriptUrlsOrRegexes.every(urlOrRegexp => {\n                    if(typeof urlOrRegexp === 'string')\n                        return !pattern.test(urlOrRegexp)\n                    else if(urlOrRegexp instanceof RegExp)\n                        return pattern.toString() !== urlOrRegexp.toString()\n                })\n            ))\n        }\n        if(patterns.whitelist) {\n            patterns.whitelist = [\n                ...patterns.whitelist,\n                ...scriptUrlsOrRegexes\n                    .map(urlOrRegexp => {\n                        if(typeof urlOrRegexp === 'string') {\n                            const escapedUrl = urlOrRegexp.replace(URL_REPLACER_REGEXP, '\\\\$&')\n                            const permissiveRegexp = '.*' + escapedUrl + '.*'\n                            if(patterns.whitelist.every(p => p.toString() !== permissiveRegexp.toString())) {\n                                return new RegExp(permissiveRegexp)\n                            }\n                        } else if(urlOrRegexp instanceof RegExp) {\n                            if(patterns.whitelist.every(p => p.toString() !== urlOrRegexp.toString())) {\n                                return urlOrRegexp\n                            }\n                        }\n                        return null\n                    })\n                    .filter(Boolean)\n            ]\n        }\n    }\n\n\n    // Parse existing tags with a marked type\n    const tags = document.querySelectorAll(`script[type=\"${TYPE_ATTRIBUTE}\"], *[${HIDDEN_SRC_ATTRIBUTE}]`)\n    for(let i = 0; i < tags.length; i++) {\n        const elem = tags[i]\n        if(willBeUnblocked(elem)) {\n            backupElements.blacklisted.push([elem, 'application/javascript'])\n            elem.parentElement.removeChild(elem)\n        }\n    }\n\n    // Exclude 'whitelisted' scripts from the blacklist and append them to <head>\n    let indexOffset = 0;\n    [...backupElements.blacklisted].forEach(([elem, type], index) => {\n        if(willBeUnblocked(elem)) {\n            const tagName = elem.tagName.toLowerCase();\n            const elementNode = document.createElement(tagName)\n            const stashedSrc = elem.getAttribute(HIDDEN_SRC_ATTRIBUTE);\n\n            if (elementNode.tagName != 'IFRAME') {\n                if (stashedSrc) {\n                    //console.log('Unstashing', stashedSrc);\n                    elementNode.setAttribute('src', stashedSrc)\n                } else {\n                    //console.log('resetting', elem.src);\n                    elementNode.setAttribute('type', type || 'application/javascript')\n                    elementNode.setAttribute('src', elem.src)\n                }\n\n                for (let key in elem) {\n                    if (key.startsWith(\"on\")) {\n                        elementNode[key] = elem[key]\n                    }\n                }\n                // insert into head\n                document.head.appendChild(elementNode)\n\n                // Special for Contao: Google Maps integrated with dlh_googlemaps extension -> we have to call init functions again\n                let contao_gmap = document.getElementsByClassName('dlh_googlemap')\n                for (let i = 0; i < contao_gmap.length; i++) {\n                    contao_gmap[i].classList.remove(\"blocked\");\n                    // check for function names of type gmap1_allow() and call\n                    let f = 'gmap'+(i+1)+'_initialize';\n                    if (typeof window[f] === 'function') {\n                        window.setTimeout(f+'()', 500);\n                    }\n                }\n            }\n\n            // Restore iframe and remove placeholder\n            else {\n                let blockedIframes = document.querySelectorAll('div.iframe-blocked[data-src]')\n                for (let i = 0; i < blockedIframes.length; i++) {\n                    if ( ! elem.src && elem.getAttribute('yett-src')) {\n                        elem.src = elem.getAttribute('yett-src')\n                    }\n                    if (blockedIframes[i].getAttribute('data-src') == elem.src) {\n                        // Insert iframe at placeholder position\n                        blockedIframes[i].parentElement && blockedIframes[i].parentElement.insertBefore(elem, blockedIframes[i])\n                        // Remove placeholder\n                        blockedIframes[i].parentElement && blockedIframes[i].parentElement.removeChild(blockedIframes[i])\n\n                    }\n                }\n            }\n\n            backupElements.blacklisted.splice(index - indexOffset, 1)\n            indexOffset++\n        }\n    })\n\n    // Disconnect the observer if the blacklist is empty for performance reasons\n    if(patterns.blacklist && patterns.blacklist.length < 1) {\n        observer.disconnect()\n    }\n}\n"],"names":["isOnBlacklist","src","type","TYPE_ATTRIBUTE","isBlacklistedSource","willBeUnblocked","script","getAttribute","patterns","blacklist","every","entry","test","whitelist","some","HIDDEN_SRC_ATTRIBUTE","window","YETT_BLACKLIST","YETT_WHITELIST","blacklistlabels","YETT_BLACKLIST_LABELS","features","YETT_IFRAME","YETT_IFRAME_BLOCKED_TEXT","YETT_IFRAME_BLOCKED_BTN","backupElements","blacklisted","return_key","srcStart","undefined","toString","split","i","pattern","index","observer","MutationObserver","mutations","length","addedNodes","node","nodeType","tagName","text","indexOf","contao_gmap","document","getElementsByClassName","classList","add","innerHTML","blacklistIndex","push","addEventListener","beforeScriptExecuteListener","event","preventDefault","removeEventListener","label","iframePlaceholder","createElement","setAttribute","style","cssText","defaultView","getComputedStyle","backgroundColor","display","alignItems","justifyContent","width","height","maxWidth","parentElement","insertBefore","removeChild","observe","documentElement","childList","subtree","createElementBackup","originalDescriptors","HTMLScriptElement","Object","getOwnPropertyDescriptor","prototype","args","toLowerCase","descriptors","bind","mockElt","defineProperties","get","call","this","set","value","typeValue","name","error","console","warn","URL_REPLACER_REGEXP","RegExp","scriptUrlsOrRegexes","filter","urlOrRegexp","map","permissiveRegexp","replace","p","Boolean","tags","querySelectorAll","elem","indexOffset","forEach","elementNode","stashedSrc","key","startsWith","head","appendChild","remove","f","setTimeout","blockedIframes","splice","disconnect"],"mappings":"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"}