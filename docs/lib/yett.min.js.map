{"version":3,"file":"yett.min.js","sources":["../../src/checks.js","../../src/variables.js","../../src/observer.js","../../src/monkey.js","../../src/unblock.js"],"sourcesContent":["import { patterns, TYPE_ATTRIBUTE } from './variables'\r\n\r\nexport const isOnBlacklist = (src, type) => (\r\n    src && (!type || type !== TYPE_ATTRIBUTE) &&\r\n    isBlacklistedSource(src)\r\n\r\n)\r\n\r\nexport const isBlacklistedSource = function(src) {\r\n  const srcStart = src === undefined ? \"\" : src.toString().split(\"?\")[0];\r\n  return srcStart &&\r\n  (\r\n    (!patterns.blacklist || patterns.blacklist.some(pattern => pattern.test(srcStart))) &&\r\n    (!patterns.whitelist || patterns.whitelist.every(pattern => !pattern.test(srcStart)))\r\n  )\r\n}\r\n\r\nexport const willBeUnblocked = function(script) {\r\n    const src = script.getAttribute('src')\r\n    return (\r\n        patterns.blacklist && patterns.blacklist.every(entry => !entry.test(src)) ||\r\n        patterns.whitelist && patterns.whitelist.some(entry => entry.test(src))\r\n    )\r\n}\r\n","export const TYPE_ATTRIBUTE = 'javascript/blocked'\r\nexport const HIDDEN_SRC_ATTRIBUTE = 'yett-src'\r\n\r\nexport const patterns = {\r\n    blacklist: window.YETT_BLACKLIST,\r\n    whitelist: window.YETT_WHITELIST\r\n}\r\n\r\nexport const features = {\r\n    iframe: window.YETT_IFRAME,\r\n    iframe_blocked_text: window.YETT_IFRAME_BLOCKED_TEXT || 'Blocked iframe content!',\r\n    iframe_blocked_btn_unblock: window.YETT_IFRAME_BLOCKED_BTN || 'Unblock',\r\n}\r\n\r\n// Backup list containing the original blacklisted elements\r\nexport const backupElements = {\r\n    blacklisted: []\r\n}\r\n","import {backupElements, TYPE_ATTRIBUTE, features} from './variables'\r\nimport { isOnBlacklist } from './checks'\r\n\r\n// Setup a mutation observer to track DOM insertion\r\nexport const observer = new MutationObserver(mutations => {\r\n    for (let i = 0; i < mutations.length; i++) {\r\n        const { addedNodes } = mutations[i];\r\n        for(let i = 0; i < addedNodes.length; i++) {\r\n            const node = addedNodes[i]\r\n\r\n            // For each added script or iframe tag; nodeType=1 represents an Element node like <p> or <div>.\r\n            if(node.nodeType === 1 && (node.tagName === 'SCRIPT' || (features.iframe && node.tagName === 'IFRAME'))) {\r\n                const src = node.src || node.getAttribute('yett-src')\r\n                const type = node.type\r\n\r\n                // If the src is inside the blacklist and is not inside the whitelist\r\n                if(isOnBlacklist(src, type)) {\r\n\r\n                    // We backup the node\r\n                    backupElements.blacklisted.push([node, node.type])\r\n\r\n                   // Blocks inline script execution in Safari & Chrome\r\n                   node.type = TYPE_ATTRIBUTE\r\n\r\n                    // Firefox has this additional event which prevents scripts from beeing executed\r\n                    const beforeScriptExecuteListener = function (event) {\r\n                        // Prevent only marked scripts from executing\r\n                        if(node.getAttribute('type') === TYPE_ATTRIBUTE)\r\n                            event.preventDefault()\r\n                        node.removeEventListener('beforescriptexecute', beforeScriptExecuteListener)\r\n                    }\r\n                    node.addEventListener('beforescriptexecute', beforeScriptExecuteListener)\r\n\r\n                    // In case of iframe feature, add placeholder block\r\n                    if (features.iframe && node.tagName === 'IFRAME') {\r\n                        let iframePlaceholder = document.createElement('div')\r\n                        iframePlaceholder.setAttribute('data-src', src)\r\n                        // Copy styles from iframe\r\n                        iframePlaceholder.style.cssText = document.defaultView.getComputedStyle(node, '').cssText\r\n                        // Set background color + special styles\r\n                        iframePlaceholder.style.backgroundColor = '#dedede'\r\n                        iframePlaceholder.style.display = 'flex'\r\n                        iframePlaceholder.style.alignItems = 'center'\r\n                        iframePlaceholder.style.justifyContent = 'center'\r\n                        iframePlaceholder.style.width = node.getAttribute('width')+'px'\r\n                        iframePlaceholder.style.height = node.getAttribute('height')+'px'\r\n                        iframePlaceholder.classList.add('iframe-blocked')\r\n                        // Add text + Button\r\n                        iframePlaceholder.innerHTML = '<p style=\"text-align: center\">'+features.iframe_blocked_text+'<br/><button class=\"toggleConsentManager\">'+features.iframe_blocked_btn_unblock+'</button></p>'\r\n                        node.parentElement && node.parentElement.insertBefore(iframePlaceholder, node)\r\n                    }\r\n\r\n                    // Remove the node from the DOM\r\n                    node.parentElement && node.parentElement.removeChild(node)\r\n                }\r\n            }\r\n        }\r\n    }\r\n})\r\n\r\n// Starts the monitoring\r\nobserver.observe(document.documentElement, {\r\n    childList: true,\r\n    subtree: true\r\n})\r\n","import { TYPE_ATTRIBUTE, HIDDEN_SRC_ATTRIBUTE } from './variables'\r\nimport { isOnBlacklist } from './checks'\r\n\r\nconst createElementBackup = document.createElement\r\n\r\nvar originalDescriptors = {\r\n    script: {\r\n      class: HTMLScriptElement,\r\n      src: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'src'),\r\n      type: Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'type')\r\n    }\r\n}\r\n\r\n// Monkey patch the createElement method to prevent dynamic scripts from executing\r\ndocument.createElement = function(...args) {\r\n    // If this is not a patched tag, bypass\r\n    const tagName = args[0].toLowerCase()\r\n    const descriptors = originalDescriptors[tagName]\r\n    if(descriptors === undefined)\r\n        return createElementBackup.bind(document)(...args)\r\n\r\n    const mockElt = createElementBackup.bind(document)(...args)\r\n\r\n    // Define getters / setters to ensure that the script type is properly set\r\n    try {\r\n        Object.defineProperties(mockElt, {\r\n            'src': {\r\n                get() {\r\n                    return descriptors.src.get.call(this)\r\n                },\r\n                set(value) {\r\n                    if(isOnBlacklist(value, mockElt.type)) {\r\n                        if (descriptors.type) {\r\n                          descriptors.type.set.call(this, TYPE_ATTRIBUTE)\r\n                        } else {\r\n                          descriptors.class.prototype.setAttribute.call(this, HIDDEN_SRC_ATTRIBUTE, value)\r\n                          value = undefined\r\n                        }\r\n                    }\r\n\r\n                    if(value !== undefined)\r\n                      descriptors.src.set.call(this, value)\r\n                }\r\n            },\r\n            'type': {\r\n                set(value) {\r\n                    const typeValue = isOnBlacklist(mockElt.src, mockElt.type) ? TYPE_ATTRIBUTE : value\r\n                    descriptors.type.set.call(this, typeValue)\r\n                }\r\n            }\r\n        })\r\n\r\n        // Monkey patch the setAttribute function so that the setter is called instead\r\n        mockElt.setAttribute = function(name, value) {\r\n            if(name === 'type' || name === 'src') {\r\n                mockElt[name] = value\r\n            } else\r\n                descriptors.class.prototype.setAttribute.call(mockElt, name, value)\r\n        }\r\n    } catch (error) {\r\n        // eslint-disable-next-line\r\n        console.warn(\r\n            'Yett: unable to prevent script execution for ' + tagName + ' src ', mockElt.src, '.\\n',\r\n            'A likely cause would be because you are using a third-party browser extension that monkey patches the \"document.createElement\" function.'\r\n        )\r\n    }\r\n    return mockElt\r\n}\r\n","import {\r\n    patterns,\r\n    backupElements,\r\n    TYPE_ATTRIBUTE,\r\n    HIDDEN_SRC_ATTRIBUTE\r\n} from './variables'\r\n\r\nimport {\r\n    willBeUnblocked\r\n} from './checks'\r\n\r\nimport {\r\n    observer\r\n} from './observer'\r\n\r\nconst URL_REPLACER_REGEXP = new RegExp('[|\\\\{}()[\\\\]^$+*?.]', 'g')\r\n\r\n// Unblocks all (or a selection of) blacklisted scripts.\r\nexport const unblock = function(...scriptUrlsOrRegexes) {\r\n    if(scriptUrlsOrRegexes.length < 1) {\r\n        patterns.blacklist = []\r\n        patterns.whitelist = []\r\n    } else {\r\n        if(patterns.blacklist) {\r\n            patterns.blacklist = patterns.blacklist.filter(pattern => (\r\n                scriptUrlsOrRegexes.every(urlOrRegexp => {\r\n                    if(typeof urlOrRegexp === 'string')\r\n                        return !pattern.test(urlOrRegexp)\r\n                    else if(urlOrRegexp instanceof RegExp)\r\n                        return pattern.toString() !== urlOrRegexp.toString()\r\n                })\r\n            ))\r\n        }\r\n        if(patterns.whitelist) {\r\n            patterns.whitelist = [\r\n                ...patterns.whitelist,\r\n                ...scriptUrlsOrRegexes\r\n                    .map(urlOrRegexp => {\r\n                        if(typeof urlOrRegexp === 'string') {\r\n                            const escapedUrl = urlOrRegexp.replace(URL_REPLACER_REGEXP, '\\\\$&')\r\n                            const permissiveRegexp = '.*' + escapedUrl + '.*'\r\n                            if(patterns.whitelist.every(p => p.toString() !== permissiveRegexp.toString())) {\r\n                                return new RegExp(permissiveRegexp)\r\n                            }\r\n                        } else if(urlOrRegexp instanceof RegExp) {\r\n                            if(patterns.whitelist.every(p => p.toString() !== urlOrRegexp.toString())) {\r\n                                return urlOrRegexp\r\n                            }\r\n                        }\r\n                        return null\r\n                    })\r\n                    .filter(Boolean)\r\n            ]\r\n        }\r\n    }\r\n\r\n\r\n    // Parse existing tags with a marked type\r\n    const tags = document.querySelectorAll(`script[type=\"${TYPE_ATTRIBUTE}\"], *[${HIDDEN_SRC_ATTRIBUTE}]`)\r\n    for(let i = 0; i < tags.length; i++) {\r\n        const elem = tags[i]\r\n        if(willBeUnblocked(elem)) {\r\n            backupElements.blacklisted.push([elem, 'application/javascript'])\r\n            elem.parentElement.removeChild(elem)\r\n        }\r\n    }\r\n\r\n    // Exclude 'whitelisted' scripts from the blacklist and append them to <head>\r\n    let indexOffset = 0;\r\n    [...backupElements.blacklisted].forEach(([elem, type], index) => {\r\n        if(willBeUnblocked(elem)) {\r\n            const tagName = elem.tagName.toLowerCase();\r\n            const elementNode = document.createElement(tagName)\r\n            const stashedSrc = elem.getAttribute(HIDDEN_SRC_ATTRIBUTE);\r\n\r\n            if (elementNode.tagName != 'IFRAME') {\r\n                if (stashedSrc) {\r\n                    //console.log('Unstashing', stashedSrc);\r\n                    elementNode.setAttribute('src', stashedSrc)\r\n                } else {\r\n                    //console.log('resetting', elem.src);\r\n                    elementNode.setAttribute('type', type || 'application/javascript')\r\n                    elementNode.setAttribute('src', elem.src)\r\n                }\r\n\r\n                for (let key in elem) {\r\n                    if (key.startsWith(\"on\")) {\r\n                        elementNode[key] = elem[key]\r\n                    }\r\n                }\r\n                // insert into head\r\n                document.head.appendChild(elementNode)\r\n            }\r\n\r\n            // Restore iframe and remove placeholder\r\n            else {\r\n                let blockedIframes = document.querySelectorAll('div.iframe-blocked[data-src]')\r\n                for (let i = 0; i < blockedIframes.length; i++) {\r\n                    if ( ! elem.src && elem.getAttribute('yett-src')) {\r\n                        elem.src = elem.getAttribute('yett-src')\r\n                    }\r\n                    if (blockedIframes[i].getAttribute('data-src') == elem.src) {\r\n                        // Insert iframe at placeholder position\r\n                        blockedIframes[i].parentElement && blockedIframes[i].parentElement.insertBefore(elem, blockedIframes[i])\r\n                        // Remove placeholder\r\n                        blockedIframes[i].parentElement && blockedIframes[i].parentElement.removeChild(blockedIframes[i])\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n            backupElements.blacklisted.splice(index - indexOffset, 1)\r\n            indexOffset++\r\n        }\r\n    })\r\n\r\n    // Disconnect the observer if the blacklist is empty for performance reasons\r\n    if(patterns.blacklist && patterns.blacklist.length < 1) {\r\n        observer.disconnect()\r\n    }\r\n}\r\n"],"names":["isOnBlacklist","src","type","TYPE_ATTRIBUTE","isBlacklistedSource","willBeUnblocked","script","getAttribute","patterns","blacklist","every","entry","test","whitelist","some","HIDDEN_SRC_ATTRIBUTE","window","YETT_BLACKLIST","YETT_WHITELIST","features","YETT_IFRAME","YETT_IFRAME_BLOCKED_TEXT","YETT_IFRAME_BLOCKED_BTN","backupElements","blacklisted","srcStart","undefined","toString","split","pattern","observer","MutationObserver","mutations","i","length","addedNodes","node","nodeType","tagName","push","addEventListener","beforeScriptExecuteListener","event","preventDefault","removeEventListener","iframePlaceholder","document","createElement","setAttribute","style","cssText","defaultView","getComputedStyle","backgroundColor","display","alignItems","justifyContent","width","height","classList","add","innerHTML","parentElement","insertBefore","removeChild","observe","documentElement","childList","subtree","createElementBackup","originalDescriptors","HTMLScriptElement","Object","getOwnPropertyDescriptor","prototype","args","toLowerCase","descriptors","bind","mockElt","defineProperties","get","call","this","set","value","typeValue","name","error","console","warn","URL_REPLACER_REGEXP","RegExp","scriptUrlsOrRegexes","filter","urlOrRegexp","map","permissiveRegexp","replace","p","Boolean","tags","querySelectorAll","elem","indexOffset","forEach","index","elementNode","stashedSrc","key","startsWith","head","appendChild","blockedIframes","splice","disconnect"],"mappings":"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"}